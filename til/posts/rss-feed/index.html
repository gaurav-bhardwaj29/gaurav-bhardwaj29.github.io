<!DOCTYPE html>
<html>
<head>
   <meta name="fediverse:creator" content="@wiredguy@mastodon.social">                  
  <link rel="stylesheet" href="../../til-style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      if (window.renderMathInElement) {
        renderMathInElement(document.body, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false}
          ]
        });
      }
    });
  </script>
  <title>Subscribe via RSS</title>
  <style>
    .upvote-btn {
      display: inline-flex;
      align-items: center;
      cursor: pointer;
      border: none;
      background: none;
      padding: 0.2em 0.4em;
      margin-left: 0.5em;
      transition: color 0.2s, transform 0.1s;
      color: #aaa;
      font-size: 1.5em;
      outline: none;
    }
    .upvote-btn:active {
      transform: scale(1.18);
    }
    .upvote-btn.upvoted {
      color: #4b4e50;
      font-weight: bold;
      /* transform: scale(1.2); -- handled by JS for pop effect */
    }
    .upvote-arrow {
      width: 1.2em;
      height: 1.2em;
      display: inline-block;
      vertical-align: middle;
      transition: stroke 0.18s, fill 0.18s;
      fill: #d1d1d1;
      stroke: #7d8082;
    }
    .upvote-btn.upvoted .upvote-arrow {
      stroke: #4b4e50;
      fill: #4b4e50;
    }
    .upvote-btn.pop {
      animation: upvote-pop 0.18s cubic-bezier(.4,1.6,.6,1) 1;
    }
    @keyframes upvote-pop {
      0% { transform: scale(1); }
      60% { transform: scale(1.28); }
      100% { transform: scale(1); }
    }
    /* ...existing code... */
  </style>
</head>
<body>
<main>
  <h1>Subscribe via RSS</h1>
  <div class="til-actions">
    <button class="upvote-btn" id="upvote-btn" title="Upvote this TIL" aria-pressed="false">
      <svg class="upvote-arrow" viewBox="0 0 24 24" fill="#d1d1d1" stroke="#7d8082" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="12,4 19,20 5,20" />
      </svg>
    </button>
    <button class="share-btn" id="share-btn" title="Share this TIL">
      <svg class="share-icon" viewBox="0 0 24 24" fill="none" stroke="#555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="5" r="3" />
        <circle cx="6" cy="12" r="3" />
        <circle cx="18" cy="19" r="3" />
        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49" />
        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49" />
      </svg>
    </button>
  </div>
  <div class="til-body"><p>Really simple syndication–commonly known as RSS is a cool (old) way that allows users to get updates for new content posted on the website. Readers subscribe to the feed to get updates on their favourite authors, content creators, influencers. The reason I say this is an old way is partly due to the automation of webpages (mailing list, push notifications etc.) and partly because most people shifted to centralised and curated platforms for content creation and consumption. For example, chrome dropped native feed support in 2013. Algorithmic feeds now dominate i.e., they “surface” content instead of manual subscriptions, though manual subscriptions are still alive via newsletters. </p>
<p>Lots of yapping ahead, if you want to see how I created RSS builder for my website, <a href="https://gist.github.com/gaurav-bhardwaj29/d917f1d076385498032cfa9aeeaa2d72">click here</a>.</p>
<p>RSS was decentralized and did not generate ad revenue. Developers and power users moved to modern tools like Feedly and Inoreader. As content moved behind walled gardens, the “mainstream” herd was drawn to relentless scrolling and absorbing “For You” feeds flavoured with cheap dopamin hits to boost the “psyche” as pretentious woke people call it. Look, I am in no way against the use of algorithm by the social media apps wanting to push algorithmic content discovery–organising feed by who, not what. I think that recommendation systems are good way to share important news, conduct social experiments and aggregate data for marketing purpose and/or organising the feed better. But this must be regulated in favour of the larger population by not forcing what needs to be displayed rather what the user wants to see. But this is not always easy and downplaying this lead to people eventually getting frustrated with doomscrolling and manipulative algorithms (especially on X, instagram). Algorithm fatigue (and a couple other factors) just compounds to the point of it being unbearable, and has been a major reason why apps like facebook witnessed their major chunk of power users (between ages 16 - 25) shift to other platforms. This is particularly the reason I decided to go with the legacy, indie web way. RSS solves this by showing exactly what you subscribed to–simple, ad free, open, and private. I am vocal about the use of decentralized blogging platforms(like bear blog, micro.blog, smol.pub) partly because it fits well with the “own your content” philosophy of the Indieweb, and partly because I believe that a better algorithm is out there which will denoise and cut through the bullshit of having two extremes–the algorithm and the anti-algorithm communities. But for the time being, having no control seems like the best control.</p>

  <!-- Perlin noise image row (only for the perlin-noise post) -->
  
  </div>
  <div class="til-date">Posted on 13 July 2025 (IST) · Follow me on <a href="https://x.com/wiredguys">Twitter</a> or <a rel="me" href="https://mastodon.social/@wiredguy">Mastodon</a></div>

<div id="turnstile-container">
  <div id="cf-turnstile" class="cf-turnstile" data-sitekey="0x4AAAAAABiDRLV2JxUJ_Qv6"></div>
</div>
  <ul class="til-list">
    <li><a href="../../index.html">← TIL</a></li>
  </ul>
  <div class="til-sidebar">
    <h5>Jump to</h5>
    <ul>
      <li><a href="../tls-handshakes/">← Previous: Integrating TLS via mbedTLS in web server</a></li>
    </ul>
  </div>
  <script>
    // --- Upvote logic ---
    const slug = "{slug}";
    const upvoteBtn = document.getElementById('upvote-btn');
    const shareBtn = document.getElementById('share-btn');
    const turnstileContainer = document.getElementById('turnstile-container');
    const sessionKey = 'cf_upvote_verified';
    const upvotedKey = 'til_upvoted_' + slug;
    function isSessionVerified() {{
      return localStorage.getItem(sessionKey) === '1';
    }}
    function setSessionVerified() {{
      localStorage.setItem(sessionKey, '1');
    }}
    function isUpvoted() {{
      return localStorage.getItem(upvotedKey) === '1';
    }}
    function setUpvoted() {{
      localStorage.setItem(upvotedKey, '1');
      upvoteBtn.classList.add('upvoted');
      upvoteBtn.setAttribute('aria-pressed', 'true');
      // Animate arrow fill and pop
      const svg = upvoteBtn.querySelector('.upvote-arrow');
      if (svg) {{
        svg.setAttribute('fill', '#4b4e50');
        svg.setAttribute('stroke', '#4b4e50');
      }}
      upvoteBtn.classList.add('pop');
      setTimeout(() => upvoteBtn.classList.remove('pop'), 180);
    }}
    function resetUpvoteBtn() {{
      upvoteBtn.classList.remove('upvoted');
      upvoteBtn.setAttribute('aria-pressed', 'false');
      const svg = upvoteBtn.querySelector('.upvote-arrow');
      if (svg) {{
        svg.setAttribute('fill', '#d1d1d1');
        svg.setAttribute('stroke', '#7d8082');
      }}
    }}
    if (isUpvoted()) {{
      setUpvoted();
      upvoteBtn.disabled = true;
    }} else {{
      resetUpvoteBtn();
      upvoteBtn.disabled = false;
    }}
    upvoteBtn.addEventListener('click', function() {{
      if (isUpvoted()) return;
      // Animate pop even before upvote completes
      upvoteBtn.classList.add('pop');
      setTimeout(() => upvoteBtn.classList.remove('pop'), 180);
      if (isSessionVerified()) {{
        sendUpvote();
      }} else {{
        turnstileContainer.style.display = 'block';
      }}
    }});
    shareBtn.addEventListener('click', function() {{
      if (navigator.share) {{
        navigator.share({{
          title: document.title,
          url: window.location.href
        }});
      }} else {{
        navigator.clipboard.writeText(window.location.href);
        shareBtn.classList.add('shared');
        shareBtn.title = 'Copied!';
        setTimeout(() => {{ shareBtn.classList.remove('shared'); shareBtn.title = 'Share this TIL'; }}, 1200);
      }}
    }});
    window.turnstileCallback = function(token) {
      // POST to backend for verification and upvote
      fetch('/api/upvote', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({slug: slug, token: token})
      }).then(r => r.json()).then(data => {
        if (data.success) {
          setSessionVerified();
          setUpvoted();
          upvoteBtn.disabled = true;
          // Fire Cloudflare Analytics event
          if (window.cfAnalytics && window.cfAnalytics.trackEvent) {
            window.cfAnalytics.trackEvent('upvote', {slug: slug, type: 'til'});
          }
        } else {
          alert('Verification failed.');
        }
        turnstileContainer.style.display = 'none';
      });
    }
    function sendUpvote() {
      fetch('/api/upvote', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({slug: slug})
      }).then r => r.json()).then(data => {
        if (data.success) {
          setUpvoted();
          upvoteBtn.disabled = true;
          if (window.cfAnalytics && window.cfAnalytics.trackEvent) {
            window.cfAnalytics.trackEvent('upvote', {slug: slug, type: 'til'});
          }
        } else {
          alert('Upvote failed.');
        }
      });
    }
    // Cloudflare Turnstile callback
    window.onloadTurnstile = function() {
      if (window.turnstile) {
        window.turnstile.render('#cf-turnstile', {
          sitekey: '0x4AAAAAABiDRLV2JxUJ_Qv6',
          callback: window.turnstileCallback
        });
      }
    }
    // Listen for Turnstile ready
    document.addEventListener('DOMContentLoaded', function() {
      if (window.turnstile) window.onloadTurnstile();
    });
  </script>
</main>
</body>
</html>
