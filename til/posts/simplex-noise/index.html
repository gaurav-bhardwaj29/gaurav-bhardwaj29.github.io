<!DOCTYPE html>
<html>
<head>
   <meta name="fediverse:creator" content="@wiredguy@mastodon.social">                  
  <link rel="stylesheet" href="../../til-style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      if (window.renderMathInElement) {
        renderMathInElement(document.body, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false}
          ]
        });
      }
    });
  </script>
  <title>finding sweet spots in simplex noise</title>
  <style>
    .upvote-btn {
      display: inline-flex;
      align-items: center;
      cursor: pointer;
      border: none;
      background: none;
      padding: 0.2em 0.4em;
      margin-left: 0.5em;
      transition: color 0.2s, transform 0.1s;
      color: #aaa;
      font-size: 1.5em;
      outline: none;
    }
    .upvote-btn:active {
      transform: scale(1.18);
    }
    .upvote-btn.upvoted {
      color: #4b4e50;
      font-weight: bold;
      /* transform: scale(1.2); -- handled by JS for pop effect */
    }
    .upvote-arrow {
      width: 1.2em;
      height: 1.2em;
      display: inline-block;
      vertical-align: middle;
      transition: stroke 0.18s, fill 0.18s;
      fill: #d1d1d1;
      stroke: #7d8082;
    }
    .upvote-btn.upvoted .upvote-arrow {
      stroke: #4b4e50;
      fill: #4b4e50;
    }
    .upvote-btn.pop {
      animation: upvote-pop 0.18s cubic-bezier(.4,1.6,.6,1) 1;
    }
    @keyframes upvote-pop {
      0% { transform: scale(1); }
      60% { transform: scale(1.28); }
      100% { transform: scale(1); }
    }
    /* ...existing code... */
  </style>
</head>
<body>
<main>
  <h1>finding sweet spots in simplex noise</h1>
  <div class="til-actions">
    <button class="upvote-btn" id="upvote-btn" title="Upvote this TIL" aria-pressed="false">
      <svg class="upvote-arrow" viewBox="0 0 24 24" fill="#d1d1d1" stroke="#7d8082" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="12,4 19,20 5,20" />
      </svg>
    </button>
    <button class="share-btn" id="share-btn" title="Share this TIL">
      <svg class="share-icon" viewBox="0 0 24 24" fill="none" stroke="#555" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="5" r="3" />
        <circle cx="6" cy="12" r="3" />
        <circle cx="18" cy="19" r="3" />
        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49" />
        <line x1="15.41" y1="6.51" x2="8.59" y2="10.49" />
      </svg>
    </button>
  </div>
  <div class="til-body"><p>Simplex noise is a type of gradient noise just like the <a href="https://gaurv.me/til/posts/perlin-noise/">Perlin noise</a>. Infact, the creator of both noises is the same person–Kenneth [Ken] Perlin. Ken thought that his implementation of perlin noise is not good enough, especially in higher dimensions, so he came up with a better algorithm to address the limitation of classic noise function. So simplex is better, what else? Obviously I am not going into the details of the algorithm (<a href="https://www.researchgate.net/publication/216813608_Simplex_noise_demystified">Stefan Gustavson already does the job far better than I ever could</a>), but let me just say how simplex performs better than the perlin noise.</p>
<ol>
<li>simplex noise requires fewer multiplications and scales to higher dimensions (4D and up) with much less computational cost, the complexity is $O(n^2)$ for $n$ dimensions instead of $O(2^n)$ of perlin noise.</li>
<li>simplex noise has no visually-significant directional artifacts.</li>
</ol>
<p>For a high-level overview, it’s enough to know that the algorithm uses something known as a simplex grid to add nearby values and produce numbers between -1 and 1 that look linearly-interpolated like classic Perlin noise. How these grids are selected? </p>
<p>For a space with $N$ dimensions, pick the simplest and most compact shape that can be repeated to fill the entire space. A straight line segment is a 1D simplex. A triangle is a 2D simplex. A square is not a 2D simplex, because it has one more corner and side than a triangle and this isn't the simplest possible shape. A straight line segment is also not a 2D simplex, because it has only a single dimension, no matter how it is oriented in 2D space. Finally, a tetrahedron is a 3D simplex. In general, <a href="https://www.math.uci.edu/~mathcircle/materials/MCsimplex.pdf">a simplex shape for $N$ dimensions has $N+1$ corners.</a> </p>
<p>I implemented OpenSimplexNoise for two-dimensional as <a href="https://patents.google.com/patent/US6867776">OpenSimplex is patented</a>. I stole the permutation table from Stefan Gustavson’s paper and refashioned the code in python.</p>
<pre class="codehilite"><code class="language-python">import math

# gradient table for 2D noise
grad3 = [
    [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0],
    [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1],
    [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
]

# permutation table
perm = [
    151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,
    140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,
    247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,
    57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,
    74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,
    60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,
    65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,
    200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,
    52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,
    207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,
    119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,
    129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,
    218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,
    81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,
    184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,
    222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
] * 2 # avoid index out of range

def fastfloor(x):
    return int(math.floor(x))

def dot(g, x, y):
    return g[0] * x + g[1] * y

def fade(t):
    return t * t * t * (t * (t * 6 - 15) + 10)

def noise2d(xin, yin):
    n0, n1, n2 = 0.0, 0.0, 0.0  # noise contributions from the three corners

    # skew the input space to determine which simplex cell we're in
    F2 = 0.5 * (math.sqrt(3.0) - 1.0)
    s = (xin + yin) * F2
    i = fastfloor(xin + s)
    j = fastfloor(yin + s)
    G2 = (3.0 - math.sqrt(3.0)) / 6.0
    t = (i + j) * G2
    X0 = i - t
    Y0 = j - t
    x0 = xin - X0
    y0 = yin - Y0

    # determine which simplex we are in
    if x0 &gt; y0:
        i1, j1 = 1, 0  # lower triangle
    else:
        i1, j1 = 0, 1  # upper triangle

    x1 = x0 - i1 + G2
    y1 = y0 - j1 + G2
    x2 = x0 - 1.0 + 2.0 * G2
    y2 = y0 - 1.0 + 2.0 * G2

    # work out the hashed gradient indices
    ii = i &amp; 255
    jj = j &amp; 255
    gi0 = perm[ii + perm[jj]] % 12
    gi1 = perm[ii + i1 + perm[jj + j1]] % 12
    gi2 = perm[ii + 1 + perm[jj + 1]] % 12

    # calculate the contribution from the three corners
    t0 = 0.5 - x0 * x0 - y0 * y0
    if t0 &lt; 0:
        n0 = 0.0
    else:
        t0 *= t0
        n0 = t0 * t0 * dot(grad3[gi0], x0, y0)

    t1 = 0.5 - x1 * x1 - y1 * y1
    if t1 &lt; 0:
        n1 = 0.0
    else:
        t1 *= t1
        n1 = t1 * t1 * dot(grad3[gi1], x1, y1)

    t2 = 0.5 - x2 * x2 - y2 * y2
    if t2 &lt; 0:
        n2 = 0.0
    else:
        t2 *= t2
        n2 = t2 * t2 * dot(grad3[gi2], x2, y2)

    # add contributions and scale to [-1,1]
    return 70.0 * (n0 + n1 + n2)
</code></pre>

<p>Here are some fractals that I created by stacking up octaves. <a href="https://x.com/wiredguys/status/1952161874956718185">This other one is on X</a>.</p>

  <!-- Perlin noise image row (only for the perlin-noise post) -->
  
    <!-- simplex noise image row (only for the simplex-noise post) -->
  
  <div style="display: flex; justify-content: center; gap: 2em; margin: 2em 0;">
    <figure style="flex: 1; text-align: center; max-width: 200px;">
      <img src="https://pub-91e1a485198740aabff1705e89606dc3.r2.dev/simplex-octaves/Gxg2zyjbwAAj3dN.png" alt="Input Image" style="width: 100%; height: auto; border-radius: 8px; box-shadow: 0 2px 8px #0001;">
      <figcaption style="margin-top: 0.7em; font-size: 1em; color: #555;"></figcaption>
    </figure>
    <figure style="flex: 1; text-align: center; max-width: 200px;">
      <img src="https://pub-91e1a485198740aabff1705e89606dc3.r2.dev/simplex-octaves/Gxg4eP9awAIyrKT.png" alt="x Perlin noise" style="width: 100%; height: auto; border-radius: 8px; box-shadow: 0 2px 8px #0001;">
      <figcaption style="margin-top: 0.7em; font-size: 1em; color: #555;"></figcaption>
    </figure>
  </div>
  
  </div>
  <div class="til-date">Posted on 04 August 2025 (IST) · Follow me on <a href="https://x.com/wiredguys">Twitter</a> or <a rel="me" href="https://mastodon.social/@wiredguy">Mastodon</a></div>

<div id="turnstile-container">
  <div id="cf-turnstile" class="cf-turnstile" data-sitekey="0x4AAAAAABiDRLV2JxUJ_Qv6"></div>
</div>
  <ul class="til-list">
    <li><a href="../../index.html">← TIL</a></li>
  </ul>
  <div class="til-sidebar">
    <h5>Jump to</h5>
    <ul>
      <li><a href="../kawaii/">← Previous: Custom browser picker on macOS with finicky</a></li>
    </ul>
  </div>
  <script>
    // --- Upvote logic ---
    const slug = "{slug}";
    const upvoteBtn = document.getElementById('upvote-btn');
    const shareBtn = document.getElementById('share-btn');
    const turnstileContainer = document.getElementById('turnstile-container');
    const sessionKey = 'cf_upvote_verified';
    const upvotedKey = 'til_upvoted_' + slug;
    function isSessionVerified() {{
      return localStorage.getItem(sessionKey) === '1';
    }}
    function setSessionVerified() {{
      localStorage.setItem(sessionKey, '1');
    }}
    function isUpvoted() {{
      return localStorage.getItem(upvotedKey) === '1';
    }}
    function setUpvoted() {{
      localStorage.setItem(upvotedKey, '1');
      upvoteBtn.classList.add('upvoted');
      upvoteBtn.setAttribute('aria-pressed', 'true');
      // Animate arrow fill and pop
      const svg = upvoteBtn.querySelector('.upvote-arrow');
      if (svg) {{
        svg.setAttribute('fill', '#4b4e50');
        svg.setAttribute('stroke', '#4b4e50');
      }}
      upvoteBtn.classList.add('pop');
      setTimeout(() => upvoteBtn.classList.remove('pop'), 180);
    }}
    function resetUpvoteBtn() {{
      upvoteBtn.classList.remove('upvoted');
      upvoteBtn.setAttribute('aria-pressed', 'false');
      const svg = upvoteBtn.querySelector('.upvote-arrow');
      if (svg) {{
        svg.setAttribute('fill', '#d1d1d1');
        svg.setAttribute('stroke', '#7d8082');
      }}
    }}
    if (isUpvoted()) {{
      setUpvoted();
      upvoteBtn.disabled = true;
    }} else {{
      resetUpvoteBtn();
      upvoteBtn.disabled = false;
    }}
    upvoteBtn.addEventListener('click', function() {{
      if (isUpvoted()) return;
      // Animate pop even before upvote completes
      upvoteBtn.classList.add('pop');
      setTimeout(() => upvoteBtn.classList.remove('pop'), 180);
      if (isSessionVerified()) {{
        sendUpvote();
      }} else {{
        turnstileContainer.style.display = 'block';
      }}
    }});
    shareBtn.addEventListener('click', function() {{
      if (navigator.share) {{
        navigator.share({{
          title: document.title,
          url: window.location.href
        }});
      }} else {{
        navigator.clipboard.writeText(window.location.href);
        shareBtn.classList.add('shared');
        shareBtn.title = 'Copied!';
        setTimeout(() => {{ shareBtn.classList.remove('shared'); shareBtn.title = 'Share this TIL'; }}, 1200);
      }}
    }});
    window.turnstileCallback = function(token) {
      // POST to backend for verification and upvote
      fetch('/api/upvote', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({slug: slug, token: token})
      }).then(r => r.json()).then(data => {
        if (data.success) {
          setSessionVerified();
          setUpvoted();
          upvoteBtn.disabled = true;
          // Fire Cloudflare Analytics event
          if (window.cfAnalytics && window.cfAnalytics.trackEvent) {
            window.cfAnalytics.trackEvent('upvote', {slug: slug, type: 'til'});
          }
        } else {
          alert('Verification failed.');
        }
        turnstileContainer.style.display = 'none';
      });
    }
    function sendUpvote() {
      fetch('/api/upvote', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({slug: slug})
      }).then r => r.json()).then(data => {
        if (data.success) {
          setUpvoted();
          upvoteBtn.disabled = true;
          if (window.cfAnalytics && window.cfAnalytics.trackEvent) {
            window.cfAnalytics.trackEvent('upvote', {slug: slug, type: 'til'});
          }
        } else {
          alert('Upvote failed.');
        }
      });
    }
    // Cloudflare Turnstile callback
    window.onloadTurnstile = function() {
      if (window.turnstile) {
        window.turnstile.render('#cf-turnstile', {
          sitekey: '0x4AAAAAABiDRLV2JxUJ_Qv6',
          callback: window.turnstileCallback
        });
      }
    }
    // Listen for Turnstile ready
    document.addEventListener('DOMContentLoaded', function() {
      if (window.turnstile) window.onloadTurnstile();
    });
  </script>
</main>
</body>
</html>
